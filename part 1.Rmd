---
title: "Untitled"
output: html_document
---

#Importations####
path <- "C:/Users/richa/Documents/Richard/Cours/ENSAE/2A/S2/Séries Temporelles/Time-Series-Forecasting-"
setwd(path)

#install.packages('zoo')
require(zoo)

#install.packages("fUnitRoots")#tests de racine unitaire plus modulables
library(fUnitRoots)
require(fUnitRoots) 

datafile <- "automobiles.csv"
data <- read.csv(datafile, sep=";")[-c(1:3),]
data <- data[rev(1:nrow(data)),]

colnames(data)<- c("dates","indices", "Codes")

# Q2 ####
dates_char <- as.character(data$dates)
dates <- as.yearmon(seq(from=1990, to=2023+1/12, by=1/12)) #
indices <- as.numeric(as.character(data$indices))
auto <- zoo(indices, order.by=dates)
dauto=diff(auto)

summary(lm(auto ~ dates))

plot(auto,ylim=c(0,170))
plot(dauto,ylim=c(-60,40))

adf <- adfTest(auto, lag=0, type="ct") #
adf

# On teste l'auto-corrélation des résidus
adfTest_valid <- function(series,kmax,type){
k <- 0
noautocorr <- 0
while (noautocorr==0){
cat(paste0("ADF with ",k, " lags: residuals OK? "))
adf <- adfTest(series,lags=k,type=type)
pvals <- Qtests(adf@test$lm$residuals,24,fitdf=length(adf@test$lm$coefficients))[,2]
if (sum(pvals<0.05,na.rm=T) == 0) {
noautocorr <- 1; cat("OK \n")}
else cat("nope \n")
k <- k + 1
}
return(adf)
}

# On teste avec la première série
adf <- adfTest_valid(auto,24,"ct")

adf <- adfTest(auto, lag=21, type="ct")
adf

# On teste avec la série différenciée
adf <- adfTest_valid(dauto,24,"nc")

adf <- adfTest(dauto, lag=23, type="nc")
adf
# Q3 ####
plot(auto,ylim=c(0,170))
plot(dauto,ylim=c(-60,40))


# Q4 ARMA ####
par(mfrow=c(1,2))
pacf(dauto);acf(dauto)

mat <- matrix(NA,nrow=pmax+1,ncol=qmax+1) #matrice vide `a remplir
rownames(mat) <- paste0("p=",0:pmax) #renomme les lignes
colnames(mat) <- paste0("q=",0:qmax) #renomme les colonnes
AICs <- mat #matrice des AIC non remplie
BICs <- mat #matrice des BIC non remplie
pqs <- expand.grid(0:pmax,0:qmax) #toutes les combinaisons possibles de p et q
for (row in 1:dim(pqs)[1]){ #boucle pour chaque (p,q)
p <- pqs[row,1] #r´ecup`ere p
q <- pqs[row,2] #r´ecup`ere q
estim <- try(arima(x,c(p,0,q),include.mean = F)) #tente d’estimer l’ARIMA
AICs[p+1,q+1] <- if (class(estim)=="try-error") NA else estim$aic #assigne l’AIC
BICs[p+1,q+1] <- if (class(estim)=="try-error") NA else BIC(estim) #assigne le BIC
}
AICs #affiche les AICs

AICs==min(AICs)

arima310 <- arima(spread,c(3,1,0),include.mean=F)
BICs #affiche les BICs

BICs==min(BICs)

arima011 <- arima(spread,c(0,1,1),include.mean=F)
# Q5 ARIMA ###
